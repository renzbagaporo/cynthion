#![doc = "Peripheral access API for SOC microcontrollers (generated using svd2rust v0.33.3 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next]
svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.33.3/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
// use core::marker::PhantomData;
// use core::ops::Deref;
// #[allow(unused_imports)]
// use generic::*;
// #[doc = r"Common register and bit access and modify traits"]
// pub mod generic;
// #[cfg(feature = "rt")]
// extern "C" {
//     fn TIMER();
//     fn UART();
//     fn GPIOA();
//     fn GPIOB();
//     fn USB0();
//     fn USB0_EP_CONTROL();
//     fn USB0_EP_IN();
//     fn USB0_EP_OUT();
//     fn USB1();
//     fn USB1_EP_CONTROL();
//     fn USB1_EP_IN();
//     fn USB1_EP_OUT();
//     fn USB2();
//     fn USB2_EP_CONTROL();
//     fn USB2_EP_IN();
//     fn USB2_EP_OUT();
//     fn UART1();
// }
// #[doc(hidden)]
// #[repr(C)]
// pub union Vector {
//     pub _handler: unsafe extern "C" fn(),
//     pub _reserved: usize,
// }
// #[cfg(feature = "rt")]
// #[doc(hidden)]
// #[no_mangle]
// pub static __EXTERNAL_INTERRUPTS: [Vector; 17] = [
//     Vector { _handler: TIMER },
//     Vector { _handler: UART },
//     Vector { _handler: GPIOA },
//     Vector { _handler: GPIOB },
//     Vector { _handler: USB0 },
//     Vector {
//         _handler: USB0_EP_CONTROL,
//     },
//     Vector {
//         _handler: USB0_EP_IN,
//     },
//     Vector {
//         _handler: USB0_EP_OUT,
//     },
//     Vector { _handler: USB1 },
//     Vector {
//         _handler: USB1_EP_CONTROL,
//     },
//     Vector {
//         _handler: USB1_EP_IN,
//     },
//     Vector {
//         _handler: USB1_EP_OUT,
//     },
//     Vector { _handler: USB2 },
//     Vector {
//         _handler: USB2_EP_CONTROL,
//     },
//     Vector {
//         _handler: USB2_EP_IN,
//     },
//     Vector {
//         _handler: USB2_EP_OUT,
//     },
//     Vector { _handler: UART1 },
// ];
#[doc(hidden)]
pub mod interrupt;
pub use self::interrupt::Interrupt;
// #[doc = "TIMER"]
// pub struct TIMER {
//     _marker: PhantomData<*const ()>,
// }
// unsafe impl Send for TIMER {}
// impl TIMER {
//     #[doc = r"Pointer to the register block"]
//     pub const PTR: *const timer::RegisterBlock = 0xf000_0100 as *const _;
//     #[doc = r"Return the pointer to the register block"]
//     #[inline(always)]
//     pub const fn ptr() -> *const timer::RegisterBlock {
//         Self::PTR
//     }
//     #[doc = r" Steal an instance of this peripheral"]
//     #[doc = r""]
//     #[doc = r" # Safety"]
//     #[doc = r""]
//     #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
//     #[doc = r" that may race with any existing instances, for example by only"]
//     #[doc = r" accessing read-only or write-only registers, or by consuming the"]
//     #[doc = r" original peripheral and using critical sections to coordinate"]
//     #[doc = r" access between multiple new instances."]
//     #[doc = r""]
//     #[doc = r" Additionally, other software such as HALs may rely on only one"]
//     #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
//     #[doc = r" no stolen instances are passed to such software."]
//     pub unsafe fn steal() -> Self {
//         Self {
//             _marker: PhantomData,
//         }
//     }
// }
// impl Deref for TIMER {
//     type Target = timer::RegisterBlock;
//     #[inline(always)]
//     fn deref(&self) -> &Self::Target {
//         unsafe { &*Self::PTR }
//     }
// }
// impl core::fmt::Debug for TIMER {
//     fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
//         f.debug_struct("TIMER").finish()
//     }
// }
// #[doc = "TIMER"]
// pub mod timer;
// #[doc = "UART"]
// pub struct UART {
//     _marker: PhantomData<*const ()>,
// }
// unsafe impl Send for UART {}
// impl UART {
//     #[doc = r"Pointer to the register block"]
//     pub const PTR: *const uart::RegisterBlock = 0xf000_0200 as *const _;
//     #[doc = r"Return the pointer to the register block"]
//     #[inline(always)]
//     pub const fn ptr() -> *const uart::RegisterBlock {
//         Self::PTR
//     }
//     #[doc = r" Steal an instance of this peripheral"]
//     #[doc = r""]
//     #[doc = r" # Safety"]
//     #[doc = r""]
//     #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
//     #[doc = r" that may race with any existing instances, for example by only"]
//     #[doc = r" accessing read-only or write-only registers, or by consuming the"]
//     #[doc = r" original peripheral and using critical sections to coordinate"]
//     #[doc = r" access between multiple new instances."]
//     #[doc = r""]
//     #[doc = r" Additionally, other software such as HALs may rely on only one"]
//     #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
//     #[doc = r" no stolen instances are passed to such software."]
//     pub unsafe fn steal() -> Self {
//         Self {
//             _marker: PhantomData,
//         }
//     }
// }
// impl Deref for UART {
//     type Target = uart::RegisterBlock;
//     #[inline(always)]
//     fn deref(&self) -> &Self::Target {
//         unsafe { &*Self::PTR }
//     }
// }
// impl core::fmt::Debug for UART {
//     fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
//         f.debug_struct("UART").finish()
//     }
// }
// #[doc = "UART"]
// pub mod uart;
// #[doc = "SPI0"]
// pub struct SPI0 {
//     _marker: PhantomData<*const ()>,
// }
// unsafe impl Send for SPI0 {}
// impl SPI0 {
//     #[doc = r"Pointer to the register block"]
//     pub const PTR: *const spi0::RegisterBlock = 0xf000_8000 as *const _;
//     #[doc = r"Return the pointer to the register block"]
//     #[inline(always)]
//     pub const fn ptr() -> *const spi0::RegisterBlock {
//         Self::PTR
//     }
//     #[doc = r" Steal an instance of this peripheral"]
//     #[doc = r""]
//     #[doc = r" # Safety"]
//     #[doc = r""]
//     #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
//     #[doc = r" that may race with any existing instances, for example by only"]
//     #[doc = r" accessing read-only or write-only registers, or by consuming the"]
//     #[doc = r" original peripheral and using critical sections to coordinate"]
//     #[doc = r" access between multiple new instances."]
//     #[doc = r""]
//     #[doc = r" Additionally, other software such as HALs may rely on only one"]
//     #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
//     #[doc = r" no stolen instances are passed to such software."]
//     pub unsafe fn steal() -> Self {
//         Self {
//             _marker: PhantomData,
//         }
//     }
// }
// impl Deref for SPI0 {
//     type Target = spi0::RegisterBlock;
//     #[inline(always)]
//     fn deref(&self) -> &Self::Target {
//         unsafe { &*Self::PTR }
//     }
// }
// impl core::fmt::Debug for SPI0 {
//     fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
//         f.debug_struct("SPI0").finish()
//     }
// }
// #[doc = "SPI0"]
// pub mod spi0;
// #[doc = "LEDS"]
// pub struct LEDS {
//     _marker: PhantomData<*const ()>,
// }
// unsafe impl Send for LEDS {}
// impl LEDS {
//     #[doc = r"Pointer to the register block"]
//     pub const PTR: *const leds::RegisterBlock = 0xf000_1000 as *const _;
//     #[doc = r"Return the pointer to the register block"]
//     #[inline(always)]
//     pub const fn ptr() -> *const leds::RegisterBlock {
//         Self::PTR
//     }
//     #[doc = r" Steal an instance of this peripheral"]
//     #[doc = r""]
//     #[doc = r" # Safety"]
//     #[doc = r""]
//     #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
//     #[doc = r" that may race with any existing instances, for example by only"]
//     #[doc = r" accessing read-only or write-only registers, or by consuming the"]
//     #[doc = r" original peripheral and using critical sections to coordinate"]
//     #[doc = r" access between multiple new instances."]
//     #[doc = r""]
//     #[doc = r" Additionally, other software such as HALs may rely on only one"]
//     #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
//     #[doc = r" no stolen instances are passed to such software."]
//     pub unsafe fn steal() -> Self {
//         Self {
//             _marker: PhantomData,
//         }
//     }
// }
// impl Deref for LEDS {
//     type Target = leds::RegisterBlock;
//     #[inline(always)]
//     fn deref(&self) -> &Self::Target {
//         unsafe { &*Self::PTR }
//     }
// }
// impl core::fmt::Debug for LEDS {
//     fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
//         f.debug_struct("LEDS").finish()
//     }
// }
// #[doc = "LEDS"]
// pub mod leds;
// #[doc = "GPIOA"]
// pub struct GPIOA {
//     _marker: PhantomData<*const ()>,
// }
// unsafe impl Send for GPIOA {}
// impl GPIOA {
//     #[doc = r"Pointer to the register block"]
//     pub const PTR: *const gpioa::RegisterBlock = 0xf000_2000 as *const _;
//     #[doc = r"Return the pointer to the register block"]
//     #[inline(always)]
//     pub const fn ptr() -> *const gpioa::RegisterBlock {
//         Self::PTR
//     }
//     #[doc = r" Steal an instance of this peripheral"]
//     #[doc = r""]
//     #[doc = r" # Safety"]
//     #[doc = r""]
//     #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
//     #[doc = r" that may race with any existing instances, for example by only"]
//     #[doc = r" accessing read-only or write-only registers, or by consuming the"]
//     #[doc = r" original peripheral and using critical sections to coordinate"]
//     #[doc = r" access between multiple new instances."]
//     #[doc = r""]
//     #[doc = r" Additionally, other software such as HALs may rely on only one"]
//     #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
//     #[doc = r" no stolen instances are passed to such software."]
//     pub unsafe fn steal() -> Self {
//         Self {
//             _marker: PhantomData,
//         }
//     }
// }
// impl Deref for GPIOA {
//     type Target = gpioa::RegisterBlock;
//     #[inline(always)]
//     fn deref(&self) -> &Self::Target {
//         unsafe { &*Self::PTR }
//     }
// }
// impl core::fmt::Debug for GPIOA {
//     fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
//         f.debug_struct("GPIOA").finish()
//     }
// }
// #[doc = "GPIOA"]
// pub mod gpioa;
// #[doc = "GPIOB"]
// pub struct GPIOB {
//     _marker: PhantomData<*const ()>,
// }
// unsafe impl Send for GPIOB {}
// impl GPIOB {
//     #[doc = r"Pointer to the register block"]
//     pub const PTR: *const gpiob::RegisterBlock = 0xf000_2100 as *const _;
//     #[doc = r"Return the pointer to the register block"]
//     #[inline(always)]
//     pub const fn ptr() -> *const gpiob::RegisterBlock {
//         Self::PTR
//     }
//     #[doc = r" Steal an instance of this peripheral"]
//     #[doc = r""]
//     #[doc = r" # Safety"]
//     #[doc = r""]
//     #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
//     #[doc = r" that may race with any existing instances, for example by only"]
//     #[doc = r" accessing read-only or write-only registers, or by consuming the"]
//     #[doc = r" original peripheral and using critical sections to coordinate"]
//     #[doc = r" access between multiple new instances."]
//     #[doc = r""]
//     #[doc = r" Additionally, other software such as HALs may rely on only one"]
//     #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
//     #[doc = r" no stolen instances are passed to such software."]
//     pub unsafe fn steal() -> Self {
//         Self {
//             _marker: PhantomData,
//         }
//     }
// }
// impl Deref for GPIOB {
//     type Target = gpiob::RegisterBlock;
//     #[inline(always)]
//     fn deref(&self) -> &Self::Target {
//         unsafe { &*Self::PTR }
//     }
// }
// impl core::fmt::Debug for GPIOB {
//     fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
//         f.debug_struct("GPIOB").finish()
//     }
// }
// #[doc = "GPIOB"]
// pub mod gpiob;
// #[doc = "USB0"]
// pub struct USB0 {
//     _marker: PhantomData<*const ()>,
// }
// unsafe impl Send for USB0 {}
// impl USB0 {
//     #[doc = r"Pointer to the register block"]
//     pub const PTR: *const usb0::RegisterBlock = 0xf000_3000 as *const _;
//     #[doc = r"Return the pointer to the register block"]
//     #[inline(always)]
//     pub const fn ptr() -> *const usb0::RegisterBlock {
//         Self::PTR
//     }
//     #[doc = r" Steal an instance of this peripheral"]
//     #[doc = r""]
//     #[doc = r" # Safety"]
//     #[doc = r""]
//     #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
//     #[doc = r" that may race with any existing instances, for example by only"]
//     #[doc = r" accessing read-only or write-only registers, or by consuming the"]
//     #[doc = r" original peripheral and using critical sections to coordinate"]
//     #[doc = r" access between multiple new instances."]
//     #[doc = r""]
//     #[doc = r" Additionally, other software such as HALs may rely on only one"]
//     #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
//     #[doc = r" no stolen instances are passed to such software."]
//     pub unsafe fn steal() -> Self {
//         Self {
//             _marker: PhantomData,
//         }
//     }
// }
// impl Deref for USB0 {
//     type Target = usb0::RegisterBlock;
//     #[inline(always)]
//     fn deref(&self) -> &Self::Target {
//         unsafe { &*Self::PTR }
//     }
// }
// impl core::fmt::Debug for USB0 {
//     fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
//         f.debug_struct("USB0").finish()
//     }
// }
// #[doc = "USB0"]
// pub mod usb0;
// #[doc = "USB0_EP_CONTROL"]
// pub struct USB0_EP_CONTROL {
//     _marker: PhantomData<*const ()>,
// }
// unsafe impl Send for USB0_EP_CONTROL {}
// impl USB0_EP_CONTROL {
//     #[doc = r"Pointer to the register block"]
//     pub const PTR: *const usb0_ep_control::RegisterBlock = 0xf000_3040 as *const _;
//     #[doc = r"Return the pointer to the register block"]
//     #[inline(always)]
//     pub const fn ptr() -> *const usb0_ep_control::RegisterBlock {
//         Self::PTR
//     }
//     #[doc = r" Steal an instance of this peripheral"]
//     #[doc = r""]
//     #[doc = r" # Safety"]
//     #[doc = r""]
//     #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
//     #[doc = r" that may race with any existing instances, for example by only"]
//     #[doc = r" accessing read-only or write-only registers, or by consuming the"]
//     #[doc = r" original peripheral and using critical sections to coordinate"]
//     #[doc = r" access between multiple new instances."]
//     #[doc = r""]
//     #[doc = r" Additionally, other software such as HALs may rely on only one"]
//     #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
//     #[doc = r" no stolen instances are passed to such software."]
//     pub unsafe fn steal() -> Self {
//         Self {
//             _marker: PhantomData,
//         }
//     }
// }
// impl Deref for USB0_EP_CONTROL {
//     type Target = usb0_ep_control::RegisterBlock;
//     #[inline(always)]
//     fn deref(&self) -> &Self::Target {
//         unsafe { &*Self::PTR }
//     }
// }
// impl core::fmt::Debug for USB0_EP_CONTROL {
//     fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
//         f.debug_struct("USB0_EP_CONTROL").finish()
//     }
// }
// #[doc = "USB0_EP_CONTROL"]
// pub mod usb0_ep_control;
// #[doc = "USB0_EP_IN"]
// pub struct USB0_EP_IN {
//     _marker: PhantomData<*const ()>,
// }
// unsafe impl Send for USB0_EP_IN {}
// impl USB0_EP_IN {
//     #[doc = r"Pointer to the register block"]
//     pub const PTR: *const usb0_ep_in::RegisterBlock = 0xf000_3080 as *const _;
//     #[doc = r"Return the pointer to the register block"]
//     #[inline(always)]
//     pub const fn ptr() -> *const usb0_ep_in::RegisterBlock {
//         Self::PTR
//     }
//     #[doc = r" Steal an instance of this peripheral"]
//     #[doc = r""]
//     #[doc = r" # Safety"]
//     #[doc = r""]
//     #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
//     #[doc = r" that may race with any existing instances, for example by only"]
//     #[doc = r" accessing read-only or write-only registers, or by consuming the"]
//     #[doc = r" original peripheral and using critical sections to coordinate"]
//     #[doc = r" access between multiple new instances."]
//     #[doc = r""]
//     #[doc = r" Additionally, other software such as HALs may rely on only one"]
//     #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
//     #[doc = r" no stolen instances are passed to such software."]
//     pub unsafe fn steal() -> Self {
//         Self {
//             _marker: PhantomData,
//         }
//     }
// }
// impl Deref for USB0_EP_IN {
//     type Target = usb0_ep_in::RegisterBlock;
//     #[inline(always)]
//     fn deref(&self) -> &Self::Target {
//         unsafe { &*Self::PTR }
//     }
// }
// impl core::fmt::Debug for USB0_EP_IN {
//     fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
//         f.debug_struct("USB0_EP_IN").finish()
//     }
// }
// #[doc = "USB0_EP_IN"]
// pub mod usb0_ep_in;
// #[doc = "USB0_EP_OUT"]
// pub struct USB0_EP_OUT {
//     _marker: PhantomData<*const ()>,
// }
// unsafe impl Send for USB0_EP_OUT {}
// impl USB0_EP_OUT {
//     #[doc = r"Pointer to the register block"]
//     pub const PTR: *const usb0_ep_out::RegisterBlock = 0xf000_3100 as *const _;
//     #[doc = r"Return the pointer to the register block"]
//     #[inline(always)]
//     pub const fn ptr() -> *const usb0_ep_out::RegisterBlock {
//         Self::PTR
//     }
//     #[doc = r" Steal an instance of this peripheral"]
//     #[doc = r""]
//     #[doc = r" # Safety"]
//     #[doc = r""]
//     #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
//     #[doc = r" that may race with any existing instances, for example by only"]
//     #[doc = r" accessing read-only or write-only registers, or by consuming the"]
//     #[doc = r" original peripheral and using critical sections to coordinate"]
//     #[doc = r" access between multiple new instances."]
//     #[doc = r""]
//     #[doc = r" Additionally, other software such as HALs may rely on only one"]
//     #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
//     #[doc = r" no stolen instances are passed to such software."]
//     pub unsafe fn steal() -> Self {
//         Self {
//             _marker: PhantomData,
//         }
//     }
// }
// impl Deref for USB0_EP_OUT {
//     type Target = usb0_ep_out::RegisterBlock;
//     #[inline(always)]
//     fn deref(&self) -> &Self::Target {
//         unsafe { &*Self::PTR }
//     }
// }
// impl core::fmt::Debug for USB0_EP_OUT {
//     fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
//         f.debug_struct("USB0_EP_OUT").finish()
//     }
// }
// #[doc = "USB0_EP_OUT"]
// pub mod usb0_ep_out;
// #[doc = "USB1"]
// pub struct USB1 {
//     _marker: PhantomData<*const ()>,
// }
// unsafe impl Send for USB1 {}
// impl USB1 {
//     #[doc = r"Pointer to the register block"]
//     pub const PTR: *const usb1::RegisterBlock = 0xf000_4000 as *const _;
//     #[doc = r"Return the pointer to the register block"]
//     #[inline(always)]
//     pub const fn ptr() -> *const usb1::RegisterBlock {
//         Self::PTR
//     }
//     #[doc = r" Steal an instance of this peripheral"]
//     #[doc = r""]
//     #[doc = r" # Safety"]
//     #[doc = r""]
//     #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
//     #[doc = r" that may race with any existing instances, for example by only"]
//     #[doc = r" accessing read-only or write-only registers, or by consuming the"]
//     #[doc = r" original peripheral and using critical sections to coordinate"]
//     #[doc = r" access between multiple new instances."]
//     #[doc = r""]
//     #[doc = r" Additionally, other software such as HALs may rely on only one"]
//     #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
//     #[doc = r" no stolen instances are passed to such software."]
//     pub unsafe fn steal() -> Self {
//         Self {
//             _marker: PhantomData,
//         }
//     }
// }
// impl Deref for USB1 {
//     type Target = usb1::RegisterBlock;
//     #[inline(always)]
//     fn deref(&self) -> &Self::Target {
//         unsafe { &*Self::PTR }
//     }
// }
// impl core::fmt::Debug for USB1 {
//     fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
//         f.debug_struct("USB1").finish()
//     }
// }
// #[doc = "USB1"]
// pub mod usb1;
// #[doc = "USB1_EP_CONTROL"]
// pub struct USB1_EP_CONTROL {
//     _marker: PhantomData<*const ()>,
// }
// unsafe impl Send for USB1_EP_CONTROL {}
// impl USB1_EP_CONTROL {
//     #[doc = r"Pointer to the register block"]
//     pub const PTR: *const usb1_ep_control::RegisterBlock = 0xf000_4040 as *const _;
//     #[doc = r"Return the pointer to the register block"]
//     #[inline(always)]
//     pub const fn ptr() -> *const usb1_ep_control::RegisterBlock {
//         Self::PTR
//     }
//     #[doc = r" Steal an instance of this peripheral"]
//     #[doc = r""]
//     #[doc = r" # Safety"]
//     #[doc = r""]
//     #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
//     #[doc = r" that may race with any existing instances, for example by only"]
//     #[doc = r" accessing read-only or write-only registers, or by consuming the"]
//     #[doc = r" original peripheral and using critical sections to coordinate"]
//     #[doc = r" access between multiple new instances."]
//     #[doc = r""]
//     #[doc = r" Additionally, other software such as HALs may rely on only one"]
//     #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
//     #[doc = r" no stolen instances are passed to such software."]
//     pub unsafe fn steal() -> Self {
//         Self {
//             _marker: PhantomData,
//         }
//     }
// }
// impl Deref for USB1_EP_CONTROL {
//     type Target = usb1_ep_control::RegisterBlock;
//     #[inline(always)]
//     fn deref(&self) -> &Self::Target {
//         unsafe { &*Self::PTR }
//     }
// }
// impl core::fmt::Debug for USB1_EP_CONTROL {
//     fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
//         f.debug_struct("USB1_EP_CONTROL").finish()
//     }
// }
// #[doc = "USB1_EP_CONTROL"]
// pub mod usb1_ep_control;
// #[doc = "USB1_EP_IN"]
// pub struct USB1_EP_IN {
//     _marker: PhantomData<*const ()>,
// }
// unsafe impl Send for USB1_EP_IN {}
// impl USB1_EP_IN {
//     #[doc = r"Pointer to the register block"]
//     pub const PTR: *const usb1_ep_in::RegisterBlock = 0xf000_4080 as *const _;
//     #[doc = r"Return the pointer to the register block"]
//     #[inline(always)]
//     pub const fn ptr() -> *const usb1_ep_in::RegisterBlock {
//         Self::PTR
//     }
//     #[doc = r" Steal an instance of this peripheral"]
//     #[doc = r""]
//     #[doc = r" # Safety"]
//     #[doc = r""]
//     #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
//     #[doc = r" that may race with any existing instances, for example by only"]
//     #[doc = r" accessing read-only or write-only registers, or by consuming the"]
//     #[doc = r" original peripheral and using critical sections to coordinate"]
//     #[doc = r" access between multiple new instances."]
//     #[doc = r""]
//     #[doc = r" Additionally, other software such as HALs may rely on only one"]
//     #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
//     #[doc = r" no stolen instances are passed to such software."]
//     pub unsafe fn steal() -> Self {
//         Self {
//             _marker: PhantomData,
//         }
//     }
// }
// impl Deref for USB1_EP_IN {
//     type Target = usb1_ep_in::RegisterBlock;
//     #[inline(always)]
//     fn deref(&self) -> &Self::Target {
//         unsafe { &*Self::PTR }
//     }
// }
// impl core::fmt::Debug for USB1_EP_IN {
//     fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
//         f.debug_struct("USB1_EP_IN").finish()
//     }
// }
// #[doc = "USB1_EP_IN"]
// pub mod usb1_ep_in;
// #[doc = "USB1_EP_OUT"]
// pub struct USB1_EP_OUT {
//     _marker: PhantomData<*const ()>,
// }
// unsafe impl Send for USB1_EP_OUT {}
// impl USB1_EP_OUT {
//     #[doc = r"Pointer to the register block"]
//     pub const PTR: *const usb1_ep_out::RegisterBlock = 0xf000_4100 as *const _;
//     #[doc = r"Return the pointer to the register block"]
//     #[inline(always)]
//     pub const fn ptr() -> *const usb1_ep_out::RegisterBlock {
//         Self::PTR
//     }
//     #[doc = r" Steal an instance of this peripheral"]
//     #[doc = r""]
//     #[doc = r" # Safety"]
//     #[doc = r""]
//     #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
//     #[doc = r" that may race with any existing instances, for example by only"]
//     #[doc = r" accessing read-only or write-only registers, or by consuming the"]
//     #[doc = r" original peripheral and using critical sections to coordinate"]
//     #[doc = r" access between multiple new instances."]
//     #[doc = r""]
//     #[doc = r" Additionally, other software such as HALs may rely on only one"]
//     #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
//     #[doc = r" no stolen instances are passed to such software."]
//     pub unsafe fn steal() -> Self {
//         Self {
//             _marker: PhantomData,
//         }
//     }
// }
// impl Deref for USB1_EP_OUT {
//     type Target = usb1_ep_out::RegisterBlock;
//     #[inline(always)]
//     fn deref(&self) -> &Self::Target {
//         unsafe { &*Self::PTR }
//     }
// }
// impl core::fmt::Debug for USB1_EP_OUT {
//     fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
//         f.debug_struct("USB1_EP_OUT").finish()
//     }
// }
// #[doc = "USB1_EP_OUT"]
// pub mod usb1_ep_out;
// #[doc = "USB2"]
// pub struct USB2 {
//     _marker: PhantomData<*const ()>,
// }
// unsafe impl Send for USB2 {}
// impl USB2 {
//     #[doc = r"Pointer to the register block"]
//     pub const PTR: *const usb2::RegisterBlock = 0xf000_5000 as *const _;
//     #[doc = r"Return the pointer to the register block"]
//     #[inline(always)]
//     pub const fn ptr() -> *const usb2::RegisterBlock {
//         Self::PTR
//     }
//     #[doc = r" Steal an instance of this peripheral"]
//     #[doc = r""]
//     #[doc = r" # Safety"]
//     #[doc = r""]
//     #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
//     #[doc = r" that may race with any existing instances, for example by only"]
//     #[doc = r" accessing read-only or write-only registers, or by consuming the"]
//     #[doc = r" original peripheral and using critical sections to coordinate"]
//     #[doc = r" access between multiple new instances."]
//     #[doc = r""]
//     #[doc = r" Additionally, other software such as HALs may rely on only one"]
//     #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
//     #[doc = r" no stolen instances are passed to such software."]
//     pub unsafe fn steal() -> Self {
//         Self {
//             _marker: PhantomData,
//         }
//     }
// }
// impl Deref for USB2 {
//     type Target = usb2::RegisterBlock;
//     #[inline(always)]
//     fn deref(&self) -> &Self::Target {
//         unsafe { &*Self::PTR }
//     }
// }
// impl core::fmt::Debug for USB2 {
//     fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
//         f.debug_struct("USB2").finish()
//     }
// }
// #[doc = "USB2"]
// pub mod usb2;
// #[doc = "USB2_EP_CONTROL"]
// pub struct USB2_EP_CONTROL {
//     _marker: PhantomData<*const ()>,
// }
// unsafe impl Send for USB2_EP_CONTROL {}
// impl USB2_EP_CONTROL {
//     #[doc = r"Pointer to the register block"]
//     pub const PTR: *const usb2_ep_control::RegisterBlock = 0xf000_5040 as *const _;
//     #[doc = r"Return the pointer to the register block"]
//     #[inline(always)]
//     pub const fn ptr() -> *const usb2_ep_control::RegisterBlock {
//         Self::PTR
//     }
//     #[doc = r" Steal an instance of this peripheral"]
//     #[doc = r""]
//     #[doc = r" # Safety"]
//     #[doc = r""]
//     #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
//     #[doc = r" that may race with any existing instances, for example by only"]
//     #[doc = r" accessing read-only or write-only registers, or by consuming the"]
//     #[doc = r" original peripheral and using critical sections to coordinate"]
//     #[doc = r" access between multiple new instances."]
//     #[doc = r""]
//     #[doc = r" Additionally, other software such as HALs may rely on only one"]
//     #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
//     #[doc = r" no stolen instances are passed to such software."]
//     pub unsafe fn steal() -> Self {
//         Self {
//             _marker: PhantomData,
//         }
//     }
// }
// impl Deref for USB2_EP_CONTROL {
//     type Target = usb2_ep_control::RegisterBlock;
//     #[inline(always)]
//     fn deref(&self) -> &Self::Target {
//         unsafe { &*Self::PTR }
//     }
// }
// impl core::fmt::Debug for USB2_EP_CONTROL {
//     fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
//         f.debug_struct("USB2_EP_CONTROL").finish()
//     }
// }
// #[doc = "USB2_EP_CONTROL"]
// pub mod usb2_ep_control;
// #[doc = "USB2_EP_IN"]
// pub struct USB2_EP_IN {
//     _marker: PhantomData<*const ()>,
// }
// unsafe impl Send for USB2_EP_IN {}
// impl USB2_EP_IN {
//     #[doc = r"Pointer to the register block"]
//     pub const PTR: *const usb2_ep_in::RegisterBlock = 0xf000_5080 as *const _;
//     #[doc = r"Return the pointer to the register block"]
//     #[inline(always)]
//     pub const fn ptr() -> *const usb2_ep_in::RegisterBlock {
//         Self::PTR
//     }
//     #[doc = r" Steal an instance of this peripheral"]
//     #[doc = r""]
//     #[doc = r" # Safety"]
//     #[doc = r""]
//     #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
//     #[doc = r" that may race with any existing instances, for example by only"]
//     #[doc = r" accessing read-only or write-only registers, or by consuming the"]
//     #[doc = r" original peripheral and using critical sections to coordinate"]
//     #[doc = r" access between multiple new instances."]
//     #[doc = r""]
//     #[doc = r" Additionally, other software such as HALs may rely on only one"]
//     #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
//     #[doc = r" no stolen instances are passed to such software."]
//     pub unsafe fn steal() -> Self {
//         Self {
//             _marker: PhantomData,
//         }
//     }
// }
// impl Deref for USB2_EP_IN {
//     type Target = usb2_ep_in::RegisterBlock;
//     #[inline(always)]
//     fn deref(&self) -> &Self::Target {
//         unsafe { &*Self::PTR }
//     }
// }
// impl core::fmt::Debug for USB2_EP_IN {
//     fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
//         f.debug_struct("USB2_EP_IN").finish()
//     }
// }
// #[doc = "USB2_EP_IN"]
// pub mod usb2_ep_in;
// #[doc = "USB2_EP_OUT"]
// pub struct USB2_EP_OUT {
//     _marker: PhantomData<*const ()>,
// }
// unsafe impl Send for USB2_EP_OUT {}
// impl USB2_EP_OUT {
//     #[doc = r"Pointer to the register block"]
//     pub const PTR: *const usb2_ep_out::RegisterBlock = 0xf000_5100 as *const _;
//     #[doc = r"Return the pointer to the register block"]
//     #[inline(always)]
//     pub const fn ptr() -> *const usb2_ep_out::RegisterBlock {
//         Self::PTR
//     }
//     #[doc = r" Steal an instance of this peripheral"]
//     #[doc = r""]
//     #[doc = r" # Safety"]
//     #[doc = r""]
//     #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
//     #[doc = r" that may race with any existing instances, for example by only"]
//     #[doc = r" accessing read-only or write-only registers, or by consuming the"]
//     #[doc = r" original peripheral and using critical sections to coordinate"]
//     #[doc = r" access between multiple new instances."]
//     #[doc = r""]
//     #[doc = r" Additionally, other software such as HALs may rely on only one"]
//     #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
//     #[doc = r" no stolen instances are passed to such software."]
//     pub unsafe fn steal() -> Self {
//         Self {
//             _marker: PhantomData,
//         }
//     }
// }
// impl Deref for USB2_EP_OUT {
//     type Target = usb2_ep_out::RegisterBlock;
//     #[inline(always)]
//     fn deref(&self) -> &Self::Target {
//         unsafe { &*Self::PTR }
//     }
// }
// impl core::fmt::Debug for USB2_EP_OUT {
//     fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
//         f.debug_struct("USB2_EP_OUT").finish()
//     }
// }
// #[doc = "USB2_EP_OUT"]
// pub mod usb2_ep_out;
// #[doc = "UART1"]
// pub struct UART1 {
//     _marker: PhantomData<*const ()>,
// }
// unsafe impl Send for UART1 {}
// impl UART1 {
//     #[doc = r"Pointer to the register block"]
//     pub const PTR: *const uart1::RegisterBlock = 0xf000_6000 as *const _;
//     #[doc = r"Return the pointer to the register block"]
//     #[inline(always)]
//     pub const fn ptr() -> *const uart1::RegisterBlock {
//         Self::PTR
//     }
//     #[doc = r" Steal an instance of this peripheral"]
//     #[doc = r""]
//     #[doc = r" # Safety"]
//     #[doc = r""]
//     #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
//     #[doc = r" that may race with any existing instances, for example by only"]
//     #[doc = r" accessing read-only or write-only registers, or by consuming the"]
//     #[doc = r" original peripheral and using critical sections to coordinate"]
//     #[doc = r" access between multiple new instances."]
//     #[doc = r""]
//     #[doc = r" Additionally, other software such as HALs may rely on only one"]
//     #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
//     #[doc = r" no stolen instances are passed to such software."]
//     pub unsafe fn steal() -> Self {
//         Self {
//             _marker: PhantomData,
//         }
//     }
// }
// impl Deref for UART1 {
//     type Target = uart1::RegisterBlock;
//     #[inline(always)]
//     fn deref(&self) -> &Self::Target {
//         unsafe { &*Self::PTR }
//     }
// }
// impl core::fmt::Debug for UART1 {
//     fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
//         f.debug_struct("UART1").finish()
//     }
// }
// #[doc = "UART1"]
// pub mod uart1;
// #[doc = "ADVERTISER"]
// pub struct ADVERTISER {
//     _marker: PhantomData<*const ()>,
// }
// unsafe impl Send for ADVERTISER {}
// impl ADVERTISER {
//     #[doc = r"Pointer to the register block"]
//     pub const PTR: *const advertiser::RegisterBlock = 0xf000_7000 as *const _;
//     #[doc = r"Return the pointer to the register block"]
//     #[inline(always)]
//     pub const fn ptr() -> *const advertiser::RegisterBlock {
//         Self::PTR
//     }
//     #[doc = r" Steal an instance of this peripheral"]
//     #[doc = r""]
//     #[doc = r" # Safety"]
//     #[doc = r""]
//     #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
//     #[doc = r" that may race with any existing instances, for example by only"]
//     #[doc = r" accessing read-only or write-only registers, or by consuming the"]
//     #[doc = r" original peripheral and using critical sections to coordinate"]
//     #[doc = r" access between multiple new instances."]
//     #[doc = r""]
//     #[doc = r" Additionally, other software such as HALs may rely on only one"]
//     #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
//     #[doc = r" no stolen instances are passed to such software."]
//     pub unsafe fn steal() -> Self {
//         Self {
//             _marker: PhantomData,
//         }
//     }
// }
// impl Deref for ADVERTISER {
//     type Target = advertiser::RegisterBlock;
//     #[inline(always)]
//     fn deref(&self) -> &Self::Target {
//         unsafe { &*Self::PTR }
//     }
// }
// impl core::fmt::Debug for ADVERTISER {
//     fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
//         f.debug_struct("ADVERTISER").finish()
//     }
// }
// #[doc = "ADVERTISER"]
// pub mod advertiser;
// #[doc = "INFO"]
// pub struct INFO {
//     _marker: PhantomData<*const ()>,
// }
// unsafe impl Send for INFO {}
// impl INFO {
//     #[doc = r"Pointer to the register block"]
//     pub const PTR: *const info::RegisterBlock = 0xf000_7100 as *const _;
//     #[doc = r"Return the pointer to the register block"]
//     #[inline(always)]
//     pub const fn ptr() -> *const info::RegisterBlock {
//         Self::PTR
//     }
//     #[doc = r" Steal an instance of this peripheral"]
//     #[doc = r""]
//     #[doc = r" # Safety"]
//     #[doc = r""]
//     #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
//     #[doc = r" that may race with any existing instances, for example by only"]
//     #[doc = r" accessing read-only or write-only registers, or by consuming the"]
//     #[doc = r" original peripheral and using critical sections to coordinate"]
//     #[doc = r" access between multiple new instances."]
//     #[doc = r""]
//     #[doc = r" Additionally, other software such as HALs may rely on only one"]
//     #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
//     #[doc = r" no stolen instances are passed to such software."]
//     pub unsafe fn steal() -> Self {
//         Self {
//             _marker: PhantomData,
//         }
//     }
// }
// impl Deref for INFO {
//     type Target = info::RegisterBlock;
//     #[inline(always)]
//     fn deref(&self) -> &Self::Target {
//         unsafe { &*Self::PTR }
//     }
// }
// impl core::fmt::Debug for INFO {
//     fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
//         f.debug_struct("INFO").finish()
//     }
// }
// #[doc = "INFO"]
// pub mod info;
// #[no_mangle]
// static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r" All the peripherals."]
#[allow(non_snake_case)]
pub struct Peripherals {
    // #[doc = "TIMER"]
    // pub TIMER: TIMER,
    // #[doc = "UART"]
    // pub UART: UART,
    // #[doc = "SPI0"]
    // pub SPI0: SPI0,
    // #[doc = "LEDS"]
    // pub LEDS: LEDS,
    // #[doc = "GPIOA"]
    // pub GPIOA: GPIOA,
    // #[doc = "GPIOB"]
    // pub GPIOB: GPIOB,
    // #[doc = "USB0"]
    // pub USB0: USB0,
    // #[doc = "USB0_EP_CONTROL"]
    // pub USB0_EP_CONTROL: USB0_EP_CONTROL,
    // #[doc = "USB0_EP_IN"]
    // pub USB0_EP_IN: USB0_EP_IN,
    // #[doc = "USB0_EP_OUT"]
    // pub USB0_EP_OUT: USB0_EP_OUT,
    // #[doc = "USB1"]
    // pub USB1: USB1,
    // #[doc = "USB1_EP_CONTROL"]
    // pub USB1_EP_CONTROL: USB1_EP_CONTROL,
    // #[doc = "USB1_EP_IN"]
    // pub USB1_EP_IN: USB1_EP_IN,
    // #[doc = "USB1_EP_OUT"]
    // pub USB1_EP_OUT: USB1_EP_OUT,
    // #[doc = "USB2"]
    // pub USB2: USB2,
    // #[doc = "USB2_EP_CONTROL"]
    // pub USB2_EP_CONTROL: USB2_EP_CONTROL,
    // #[doc = "USB2_EP_IN"]
    // pub USB2_EP_IN: USB2_EP_IN,
    // #[doc = "USB2_EP_OUT"]
    // pub USB2_EP_OUT: USB2_EP_OUT,
    // #[doc = "UART1"]
    // pub UART1: UART1,
    // #[doc = "ADVERTISER"]
    // pub ADVERTISER: ADVERTISER,
    // #[doc = "INFO"]
    // pub INFO: INFO,
}
impl Peripherals {
    #[doc = r" Returns all the peripherals *once*."]
    #[cfg(feature = "critical-section")]
    #[inline]
    pub fn take() -> Option<Self> {
        critical_section::with(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                return None;
            }
            Some(unsafe { Peripherals::steal() })
        })
    }
    #[doc = r" Unchecked version of `Peripherals::take`."]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Each of the returned peripherals must be used at most once."]
    #[inline]
    pub unsafe fn steal() -> Self {
        // DEVICE_PERIPHERALS = true;
        Peripherals {
        //     TIMER: TIMER {
        //         _marker: PhantomData,
        //     },
        //     UART: UART {
        //         _marker: PhantomData,
        //     },
        //     SPI0: SPI0 {
        //         _marker: PhantomData,
        //     },
        //     LEDS: LEDS {
        //         _marker: PhantomData,
        //     },
        //     GPIOA: GPIOA {
        //         _marker: PhantomData,
        //     },
        //     GPIOB: GPIOB {
        //         _marker: PhantomData,
        //     },
        //     USB0: USB0 {
        //         _marker: PhantomData,
        //     },
        //     USB0_EP_CONTROL: USB0_EP_CONTROL {
        //         _marker: PhantomData,
        //     },
        //     USB0_EP_IN: USB0_EP_IN {
        //         _marker: PhantomData,
        //     },
        //     USB0_EP_OUT: USB0_EP_OUT {
        //         _marker: PhantomData,
        //     },
        //     USB1: USB1 {
        //         _marker: PhantomData,
        //     },
        //     USB1_EP_CONTROL: USB1_EP_CONTROL {
        //         _marker: PhantomData,
        //     },
        //     USB1_EP_IN: USB1_EP_IN {
        //         _marker: PhantomData,
        //     },
        //     USB1_EP_OUT: USB1_EP_OUT {
        //         _marker: PhantomData,
        //     },
        //     USB2: USB2 {
        //         _marker: PhantomData,
        //     },
        //     USB2_EP_CONTROL: USB2_EP_CONTROL {
        //         _marker: PhantomData,
        //     },
        //     USB2_EP_IN: USB2_EP_IN {
        //         _marker: PhantomData,
        //     },
        //     USB2_EP_OUT: USB2_EP_OUT {
        //         _marker: PhantomData,
        //     },
        //     UART1: UART1 {
        //         _marker: PhantomData,
        //     },
        //     ADVERTISER: ADVERTISER {
        //         _marker: PhantomData,
        //     },
        //     INFO: INFO {
        //         _marker: PhantomData,
        //     },
        }
    }
}
